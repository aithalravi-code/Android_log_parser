import { escapeHtml, formatParam } from '../../utils/html.js';
import { makeTableResizable } from '../../table-resize.js';
import { makeSortable } from '../../table-sort.js';
import * as XLSX from 'xlsx';

let cccStatsData = [];
let cccColumnFilters = new Map();
let btsnoopConnectionMap = new Map();
let currentRenderJobId = 0;


// --- Constants ---
const CONTROL_FLOW_P1_MAP = {
    '00': 'Success / Continue',
    '01': 'Flow Control / Wait',
    '02': 'Error / Abort'
};

const CONTROL_FLOW_P2_MAP = {
    '00': 'Success / No Info',
    '01': 'Public Key Not Found / No Matching SPAKE2+',
    '02': 'Public Key Expired / Cert Chain Received',
    '03': 'Public Key Not Trusted / User Confirm',
    '04': 'Invalid Signature',
    '05': 'Invalid Channel',
    '06': 'Invalid Data Format',
    '07': 'Invalid Data Content',
    '08': 'Preconditions Not Fulfilled',
    '0B': 'Cert Verify Failed',
    '0F': 'Time Extension',
    '11': 'Key Creation/Verification Success',
    '7F': 'Data/Format Error',
    'A0': 'Key deleted / Not known',
    'B0': 'Doors/Trunk not closed',
    'B1': 'Vehicle not in parking state'
};

const AUTH_P1_MAP = {
    '00': 'Standard Authentication',
    '01': 'Fast Authentication',
    '02': 'Transaction Authentication',
    '03': 'Reserved',
    '04': 'Reserved'
};

const AUTH_P2_MAP = {
    '00': 'No specific info',
    '01': 'First message',
    '02': 'Subsequent message',
    '03': 'Last message',
    '04': 'Single message',
    '05': 'Chaining',
    '06': 'Reserved',
    '07': 'Reserved'
};

const COMMON_TAGS = {
    '30': 'Sequence',
    'A0': 'Status_Object',
    '83': 'Status'
};

const APDU_TAGS = {
    ...COMMON_TAGS,
    '86': 'Endpoint_ePK',
    '87': 'Vehicle_ePK',
    '4D': 'Vehicle_Identifier',
    '4C': 'Transaction_Identifier',
    '9E': 'Signature',
    '5C': 'Protocol_Version',
    '4E': 'Key_Slot',
    '57': 'Counter_Value',
    '4A': 'Confidential_Mailbox',
    '4B': 'Private_Mailbox',
    '93': 'Usage'
};

const RKE_TAGS = {
    ...COMMON_TAGS,
    '7F70': 'Request_RKE_Action',
    '7F72': 'Function_Status_Response',
    '7F73': 'Subscribe_Vehicle_Function',
    '7F74': 'Get_Function_Status',
    '7F76': 'Continue_RKE_Action',
    '7F77': 'Stop_RKE_Action',
    '80': 'Function_ID',
    '81': 'Action_ID',
    '84': 'From_Function_ID',
    '85': 'To_Function_ID',
    '86': 'Full_Update_Flag',
    '88': 'Arbitrary_Data'
};

const FUNCTION_IDS = {
    '0001': 'Central_Locking',
    '0010': 'Driving_Readiness'
};

const APDU_COMMANDS = {
    '00A4': 'SELECT',
    '8080': 'AUTH0',
    '8081': 'AUTH1',
    '803C': 'CONTROL_FLOW',
    '8071': 'CREATE_RANGING_KEY',
    '8072': 'TERMINATE_RANGING_SESSION',
    '8073': 'EXCHANGE_RANGING_DATA'
};

const RKE_STATUS_MAP = {
    '0001': { '00': 'Unlocked', '01': 'Locked', '02': 'Selective Unlocked', '03': 'Locked Safe' },
    '0002': { '00': 'Closed', '01': 'Open', '02': 'Intermediate' },
    '0010': { '00': 'Not Ready', '01': 'Ready', '02': 'Engine Running', '03': 'Engine Cranking' },
    '0012': { '00': 'Off', '01': 'On' },
    'default': { '00': 'Ok/Inactive', '01': 'Fail/Active' }
};

const UWB_TAGS = {};

const CCC_CONSTANTS = {
    MESSAGE_TYPES: {
        0x00: "Framework",
        0x01: "SE",
        0x02: "UWB Ranging Service",
        0x03: "DK Event Notification",
        0x04: "Vehicle OEM App",
        0x05: "Supplementary Service",
        0x06: "Head Unit Pairing"
    },
    UWB_RANGING_MSGS: {
        0x01: "Ranging_Capability_RQ",
        0x02: "Ranging_Capability_RS",
        0x03: "Ranging_Session_RQ",
        0x04: "Ranging_Session_RS",
        0x05: "Ranging_Session_Setup_RQ",
        0x06: "Ranging_Session_Setup_RS",
        0x07: "Ranging_Suspend_RQ",
        0x08: "Ranging_Suspend_RS",
        0x09: "Ranging_Recovery_RQ",
        0x0A: "Ranging_Recovery_RS",
        0x0B: "Configurable_Ranging_Recovery_RQ",
        0x0C: "Configurable_Ranging_Recovery_RS"
    },
    DK_EVENT_CATEGORIES: {
        0x01: "Command Complete",
        0x02: "Ranging Session Status Changed",
        0x03: "Device Ranging Intent",
        0x04: "Vehicle Status Change",
        0x05: "RKE Request",
        0x11: "DK Event Notification"
    },
    SUPPLEMENTARY_MSGS: {
        0x0D: "Time_Sync"
    },
    FRAMEWORK_MSGS: {
        0x04: "OP_CONTROL_FLOW",
        0x18: "Proprietary / Unknown"
    },
    SE_MSGS: {
        0x0B: "DK_APDU_RQ",
        0x0C: "DK_APDU_RS"
    }
};

// --- Helpers ---

const parseTLV = (hex, tagMap = COMMON_TAGS) => {
    let result = "";
    let i = 0;
    let maxIter = 100;
    let currentFunctionId = null;

    while (i < hex.length && maxIter-- > 0) {
        let nextByte = hex.substring(i, i + 2).toUpperCase();
        if (nextByte === '00' || nextByte === 'FF') {
            i += 2;
            continue;
        }

        let tag = nextByte;
        if (!/^[0-9A-F]{2}$/i.test(tag)) break;

        i += 2;
        if ((parseInt(tag, 16) & 0x1F) === 0x1F) {
            tag += hex.substring(i, i + 2).toUpperCase();
            i += 2;
        }

        if (i + 2 > hex.length) break;
        let lenHex = hex.substring(i, i + 2);
        let len = parseInt(lenHex, 16);
        i += 2;

        if (len > 127) {
            if (len === 0x81) {
                if (i + 2 > hex.length) break;
                len = parseInt(hex.substring(i, i + 2), 16);
                i += 2;
            } else if (len === 0x82) {
                if (i + 4 > hex.length) break;
                len = parseInt(hex.substring(i, i + 4), 16);
                i += 4;
            }
        }

        if (i + (len * 2) > hex.length) {
            result += `<div class="tlv-block">${formatParam(`Tag_${tag}`, '[Truncated]')}</div>`;
            break;
        }

        let val = hex.substring(i, i + (len * 2));
        i += (len * 2);

        const tagName = tagMap[tag] || `Tag_${tag}`;

        if (tag.startsWith('7F') || tag === '30' || tag === 'A0') {
            const nested = parseTLV(val, tagMap);
            result += `<div class="tlv-block"><span class="ccc-param">${tagName}:</span><div class="tlv-indent">${nested}</div></div>`;
        } else {
            let displayVal = val;

            if (tagMap === RKE_TAGS) {
                if (tag === '80') {
                    currentFunctionId = val;
                    if (FUNCTION_IDS[val]) displayVal = `${val} (${FUNCTION_IDS[val]})`;
                }
                if (tag === '83') {
                    const map = RKE_STATUS_MAP[currentFunctionId] || RKE_STATUS_MAP['default'];
                    const statusText = map[val] || map['default'];
                    if (statusText) displayVal = `${val} (${statusText})`;
                }
                if (tag === '86' && len === 0) displayVal = "True";
            }

            result += `<div class="tlv-block">${formatParam(tagName, displayVal)}</div>`;
        }
    }
    return result;
};

const decodePayload = (type, subtype, payload) => {
    let innerMsg = "-";
    let params = "";

    if (!payload) return { innerMsg, params: "" };

    if (type === 0x00) {
        if (subtype === 0x04) {
            innerMsg = "Data PDU";
            const dataParts = payload.match(/.{1,2}/g);
            params = formatParam('Data', dataParts ? dataParts.join(' ') : payload);
            return { innerMsg, params };
        }
        if (subtype === 0x18) {
            innerMsg = "Encrypted PDU";
            let info = "";
            if (payload.toLowerCase().includes('a0')) info = formatParam('Info', '[Contains TLV Data]') + " ";
            const dataParts = payload.match(/.{1,2}/g);
            params = info + formatParam('Data', dataParts ? dataParts.join(' ') : payload);
            return { innerMsg, params };
        }
    }

    if (type === 0x01) {
        if (subtype === 0x0B) {
            if (payload.length >= 4) {
                let apdu = payload.substring(4);
                const cla = apdu.substring(0, 2).toUpperCase();
                const ins = apdu.substring(2, 4).toUpperCase();
                const claIns = cla + ins;

                if (cla === 'C9') {
                    innerMsg = "EXCHANGE_APDU";
                    if (apdu.length >= 10) {
                        const data = apdu.substring(10);
                        params = parseTLV(data, APDU_TAGS);
                    } else {
                        params = formatParam('Data', apdu.match(/.{1,2}/g).join(' '));
                    }
                } else if (APDU_COMMANDS[claIns]) {
                    const cmdName = APDU_COMMANDS[claIns];
                    const p1 = apdu.substring(4, 6);
                    const p2 = apdu.substring(6, 8);
                    const dataStart = 10;
                    const data = apdu.substring(dataStart);

                    innerMsg = cmdName;
                    let p1Text = p1;
                    let p2Text = p2;

                    if (cmdName === 'SELECT') {
                        if (p1 === '04' && data.length > 0) {
                            if (data.toLowerCase().includes('a000000809434343444b417631')) {
                                params = formatParam('Applet', 'Digital Key') + formatParam('AID', data);
                            } else {
                                params = formatParam('AID', data);
                            }
                        }
                        return { innerMsg, params };

                    } else if (cmdName === 'CONTROL_FLOW') {
                        p1Text = CONTROL_FLOW_P1_MAP[p1] || p1;
                        p2Text = CONTROL_FLOW_P2_MAP[p2] || p2;
                    } else if (cmdName === 'AUTH0' || cmdName === 'AUTH1') {
                        p1Text = AUTH_P1_MAP[p1] || p1;
                        p2Text = AUTH_P2_MAP[p2] || p2;
                    }

                    const commonParams = formatParam('P1', `${p1Text} (0x${p1})`) +
                        formatParam('P2', `${p2Text} (0x${p2})`);

                    if (!params) params = "";
                    params = commonParams + params;

                    if (data.length > 0) {
                        const tlv = parseTLV(data, APDU_TAGS);
                        if (tlv) {
                            params += formatParam('Data (TLV)', tlv);
                        } else {
                            params += formatParam('Data', data.match(/.{1,2}/g).join(' '));
                        }
                    }
                } else if (apdu.startsWith('8080')) {
                    innerMsg = "AUTH0";
                    params = parseTLV(apdu.substring(10), APDU_TAGS);
                } else {
                    innerMsg = "APDU";
                    if (claIns === '8071') {
                        innerMsg = "CREATE_RANGING_KEY";
                        params = parseTLV(apdu.substring(10), APDU_TAGS);
                    } else if (claIns === '8072') {
                        innerMsg = "TERMINATE_RANGING_SESSION";
                        params = parseTLV(apdu.substring(10), APDU_TAGS);
                    } else if (claIns === '8073') {
                        innerMsg = "EXCHANGE_RANGING_DATA";
                        params = parseTLV(apdu.substring(10), APDU_TAGS);
                    } else {
                        params = formatParam('Data', apdu.match(/.{1,2}/g).join(' '));
                    }
                }
                return { innerMsg, params };
            }
        }
        if (subtype === 0x0C) {
            if (payload.length >= 4) {
                const lenVal = parseInt(payload.substring(0, 4), 16);
                const apdu = payload.substring(4);
                if (apdu.length >= 4) {
                    const sw = apdu.substring(apdu.length - 4);
                    const data = apdu.substring(0, apdu.length - 4);
                    let statusText = sw;
                    if (sw === '9000') statusText = 'Success (9000)';

                    innerMsg = "Response";

                    const swHtml = formatParam('SW', statusText);
                    let tlvHtml = "";

                    if (data.length > 0) {
                        const tlv = parseTLV(data, APDU_TAGS);
                        if (tlv && !tlv.includes('[Truncated') && !data.startsWith('04')) {
                            tlvHtml = formatParam('Data', tlv);
                        } else {
                            tlvHtml = formatParam('Data', data.match(/.{1,2}/g).join(' '));
                        }
                    }
                    return { innerMsg, params: tlvHtml + swHtml };
                }
            }
        }
    }

    if (type === 0x02) {
        innerMsg = "-";
        if (subtype === 0x03) {
            if (payload.length >= 24) {
                params = formatParam('Length', '0x' + payload.substring(0, 4)) +
                    formatParam('Protocol', '0x' + payload.substring(4, 8)) +
                    formatParam('ConfigID', '0x' + payload.substring(8, 12)) +
                    formatParam('SessionID', '0x' + payload.substring(12, 20)) +
                    formatParam('PulseShape', '0x' + payload.substring(20, 22)) +
                    formatParam('Channel', '0x' + payload.substring(22, 24));
                if (payload.length > 24) {
                    params += formatParam('Data (Remaining)', payload.substring(24).match(/.{1,2}/g).join(' '));
                }
            } else {
                params = formatParam('Data', payload.match(/.{1,2}/g).join(' '));
            }
        }
        if (subtype === 0x04) {
            if (payload.length >= 4) {
                params = formatParam('Length', '0x' + payload.substring(0, 4));
                const content = payload.substring(4);
                if (content.length >= 16) {
                    const ranMult = parseInt(content.substring(0, 2), 16);
                    const slotMask = content.substring(2, 4);
                    const syncMask = content.substring(4, 12);
                    const channelHex = content.substring(12, 14);
                    const hoppingHex = content.substring(14, 16);
                    const channelVal = parseInt(channelHex, 16);
                    let channelText = `Channel ${channelVal}`;
                    if (channelVal === 5) channelText = "Channel 5";
                    if (channelVal === 9) channelText = "Channel 9";

                    params += formatParam('RAN_Multiplier', ranMult) +
                        formatParam('Slot_BitMask', '0x' + slotMask) +
                        formatParam('SYNC_Code_Index_BitMask', '0x' + syncMask) +
                        formatParam('Selected_UWB_Channel', `${channelText} (0x${channelHex})`) +
                        formatParam('Hopping_Config_Bitmask', `0x${hoppingHex}`);

                    if (content.length > 16) {
                        params += formatParam('Data (Remaining)', content.substring(16).match(/.{1,2}/g).join(' '));
                    }
                } else {
                    const tlv = parseTLV(content, UWB_TAGS);
                    if (tlv) params += tlv;
                    else params += formatParam('Data', content.match(/.{1,2}/g)?.join(' ') || content);
                }
            }
        }
        if (subtype === 0x05) {
            if (payload.length >= 4) {
                params = formatParam('Length', '0x' + payload.substring(0, 4));
                const content = payload.substring(4);
                if (content.length >= 18) {
                    params += formatParam('Session_RAN_Multiplier', parseInt(content.substring(0, 2), 16)) +
                        formatParam('Number_Chaps_per_Slot', parseInt(content.substring(2, 4), 16)) +
                        formatParam('Number_Responders_Nodes', parseInt(content.substring(4, 6), 16)) +
                        formatParam('Number_Slots_per_Round', parseInt(content.substring(6, 8), 16)) +
                        formatParam('SYNC_Code_Index', parseInt(content.substring(8, 16), 16)) +
                        formatParam('Selected_Hopping_Config_Bitmask', '0x' + content.substring(16, 18));
                    if (content.length > 18) {
                        params += formatParam('Data (Remaining)', content.substring(18).match(/.{1,2}/g).join(' '));
                    }
                } else {
                    params += formatParam('Data', content.match(/.{1,2}/g)?.join(' ') || '');
                }
            }
        }
        if (subtype === 0x06) {
            if (payload.length >= 4) {
                params = formatParam('Length', '0x' + payload.substring(0, 4));
                const content = payload.substring(4);
                if (content.length >= 34) {
                    params += formatParam('STS_Index0', '0x' + content.substring(0, 8)) +
                        formatParam('UWB_Time0', '0x' + content.substring(8, 24)) +
                        formatParam('HOP_Key', '0x' + content.substring(24, 32)) +
                        formatParam('SYNC_Index', parseInt(content.substring(32, 34), 16));
                    if (content.length > 34) {
                        params += formatParam('Data (Remaining)', content.substring(34).match(/.{1,2}/g).join(' '));
                    }
                } else {
                    params += formatParam('Data', content.match(/.{1,2}/g)?.join(' ') || '');
                }
            }
        }
        if (subtype === 0x07) {
            if (payload.startsWith('0004') && payload.length >= 12) {
                params = formatParam('UWB Session ID', '0x' + payload.substring(4, 12));
                if (payload.length > 12) {
                    params += formatParam('Data (Remaining)', payload.substring(12).match(/.{1,2}/g).join(' '));
                }
            }
        }
        if (subtype === 0x08) {
            const status = payload.length >= 2 ? payload.substring(payload.length - 2) : payload;
            const statusText = status === '00' ? 'Accepted' : status === '01' ? 'Delayed' : 'Unknown (0x' + status + ')';
            params = formatParam('Suspend Response', statusText);
        }
        if (subtype === 0x09) {
            if (payload.startsWith('0004') && payload.length >= 12) {
                params = formatParam('UWB Session ID', '0x' + payload.substring(4, 12));
                if (payload.length > 12) {
                    params += formatParam('Data (Remaining)', payload.substring(12).match(/.{1,2}/g).join(' '));
                }
            }
        }
        if (subtype === 0x0A) {
            if (payload.length >= 24) {
                params = formatParam('STS_Index0', '0x' + payload.substring(0, 8)) +
                    formatParam('UWB_Time0', '0x' + payload.substring(8, 24));
                if (payload.length > 24) {
                    params += formatParam('Data (Remaining)', payload.substring(24).match(/.{1,2}/g).join(' '));
                }
            }
        }
        if (params && params !== "") return { innerMsg, params };
    }

    if (type === 0x03) {
        if (subtype === 0x11) {
            if (payload.length > 4) {
                const actualPayload = payload.substring(4);
                const category = actualPayload.substring(0, 2);
                const data = actualPayload.substring(2);

                const CATEGORIES = {
                    '01': 'Command Complete',
                    '02': 'Ranging Session Status',
                    '03': 'Device Ranging Intent',
                    '04': 'Vehicle Status',
                    '05': 'RKE Request',
                    '06': 'RKE Acknowledge'
                };

                innerMsg = CATEGORIES[category] || `Category_0x${category}`;
                params = formatParam('Data', data);

                if (category === '01') {
                    const code = data.length >= 2 ? data.substring(0, 2) : '';
                    let codeDesc = 'Unknown';
                    if (code === '80') codeDesc = 'General Error';
                    if (code === '00') codeDesc = 'Deselect_SE';
                    params = formatParam('Status', codeDesc) + formatParam('Code', '0x' + code);
                }

                if (category === '02') {
                    const code = data.length >= 2 ? data.substring(0, 2) : '';
                    const statusMap = {
                        '00': 'URSK Refresh',
                        '01': 'URSK Not Found',
                        '02': 'Not Required',
                        '03': 'Secure Ranging Failed',
                        '04': 'Terminated',
                        '06': 'Recovery Failed',
                        '07': 'Suspended'
                    };
                    params = formatParam('Status', statusMap[code] || '0x' + code);
                }

                if (category === '03') {
                    const code = data.length >= 2 ? data.substring(0, 2) : '';
                    const levelMap = {
                        '00': 'Low Confidence',
                        '01': 'Medium Confidence',
                        '02': 'High Confidence'
                    };
                    params = formatParam('Level', levelMap[code] || '0x' + code);
                }

                if (category === '04' || category === '05') {
                    params = parseTLV(data, RKE_TAGS);
                }

                const upperData = data.toUpperCase();
                if ((category !== '04' && category !== '05') && (upperData.startsWith('7F') || upperData.startsWith('30'))) {
                    params = parseTLV(data, RKE_TAGS);
                }
                return { innerMsg, params };
            }
        }
        if (subtype === 0x03) return { innerMsg: "Legacy Intent", params: formatParam('Data', payload) };
    }

    if (type === 0x05) {
        if (subtype === 0x0D) {
            innerMsg = "Time_Sync";
            if (payload.length >= 46) {
                const eventCount = BigInt('0x' + payload.substring(0, 16));
                const uwbTime = BigInt('0x' + payload.substring(16, 32));
                const uncertainty = parseInt(payload.substring(32, 34), 16);
                const skewAvail = parseInt(payload.substring(34, 36), 16);
                const ppm = parseInt(payload.substring(36, 40), 16);
                const success = parseInt(payload.substring(40, 42), 16);

                params = formatParam('EventCount', eventCount) +
                    formatParam('UWB Time', uwbTime) +
                    formatParam('Uncertainty', '0x' + uncertainty.toString(16)) +
                    formatParam('Skew', skewAvail) +
                    formatParam('PPM', ppm) +
                    formatParam('Success', success);
                return { innerMsg, params };
            }
        }
    }

    return { innerMsg, params: formatParam('Payload', (payload.match(/.{1,2}/g) || [payload]).join(' ')) };
};

// --- Exported Functions ---

export function reset() {
    cccStatsData = [];
    cccColumnFilters.clear();
    btsnoopConnectionMap = new Map();
    currentRenderJobId++; // Invalidate any ongoing rendering
    console.log('[CccTab] State reset');
}

export async function setup(btsnoopPackets, connectionMap, ensureBtsnoopProcessedFn) {

    if (ensureBtsnoopProcessedFn) {
        await ensureBtsnoopProcessedFn();
    }

    // Capture connection map
    btsnoopConnectionMap = connectionMap || new Map();

    if ((!cccStatsData || cccStatsData.length === 0) && btsnoopPackets && btsnoopPackets.length > 0) {
        cccStatsData = btsnoopPackets;
    } else if (btsnoopPackets && btsnoopPackets.length > 0) {
        // Maybe implement merge/update logic if needed, for new files
        // For now, simpler is better:
        const freshData = btsnoopPackets;
        if (freshData.length > cccStatsData.length) {
            cccStatsData = freshData;
        }
    }

    render(cccStatsData);
}

function render(messages) {
    cccStatsData = messages || [];

    const container = document.getElementById('cccStatsContainer');
    if (!container) return;

    if (!container.querySelector('table')) {
        container.innerHTML = `
        <div class="table-container" style="overflow-x: auto;">
            <table class="log-table ccc-table" id="cccStatsTable">
                <thead>
                    <tr id="cccHeaderRow">
                        <th style="width: 140px;">Time</th>
                        <th style="width: 150px;">BLE Address</th>
                        <th style="width: 60px;">Dir</th>
                        <th style="width: 150px;">Message Category</th>
                        <th style="width: 125px;">Message Type</th>
                        <th style="width: 90px;">Message</th>
                        <th style="width: 400px;">Parameters</th>
                        <th style="width: 200px;">Raw Data</th>
                    </tr>
                    <tr class="filter-row">
                        <th style="width: 140px;"><input type="text" placeholder="Filter..." data-col="0"></th>
                        <th style="width: 150px;"><input type="text" placeholder="Filter..." data-col="1"></th>
                        <th style="width: 60px;"><input type="text" placeholder="Filter..." data-col="2"></th>
                        <th style="width: 150px;"><input type="text" placeholder="Filter..." data-col="3"></th>
                        <th style="width: 125px;"><input type="text" placeholder="Filter..." data-col="4"></th>
                        <th style="width: 90px;"><input type="text" placeholder="Filter..." data-col="5"></th>
                        <th style="width: 400px;"><input type="text" placeholder="Filter..." data-col="6"></th>
                        <th style="width: 200px;"><input type="text" placeholder="Filter..." data-col="7"></th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>`;

        const inputs = container.querySelectorAll('.filter-row input');
        inputs.forEach(input => {
            input.addEventListener('input', (e) => {
                const colIndex = parseInt(e.target.dataset.col, 10);
                const value = e.target.value.toLowerCase();
                if (value) {
                    cccColumnFilters.set(colIndex, value);
                } else {
                    cccColumnFilters.delete(colIndex);
                }
                updateCccTableBody(container);
            });
        });

        if (typeof makeTableResizable === 'function') {
            makeTableResizable('cccStatsTable');
        }

        const exportCccBtn = document.getElementById('exportCccBtn');
        if (exportCccBtn) {
            exportCccBtn.addEventListener('click', () => {
                if (!cccStatsData || cccStatsData.length === 0) {
                    alert('No CCC data to export.');
                    return;
                }

                const exportData = cccStatsData.map(msg => {
                    const categoryName = CCC_CONSTANTS.MESSAGE_TYPES[msg.type] || `Unknown (0x${msg.type.toString(16).padStart(2, '0').toUpperCase()})`;
                    let typeName = `Unknown`;
                    if (msg.type === 0x02) typeName = CCC_CONSTANTS.UWB_RANGING_MSGS[msg.subtype] || typeName;
                    else if (msg.type === 0x03) typeName = CCC_CONSTANTS.DK_EVENT_CATEGORIES[msg.subtype] || typeName;
                    else if (msg.type === 0x01 && CCC_CONSTANTS.SE_MSGS && CCC_CONSTANTS.SE_MSGS[msg.subtype]) typeName = CCC_CONSTANTS.SE_MSGS[msg.subtype];
                    else if (msg.type === 0x05) typeName = CCC_CONSTANTS.SUPPLEMENTARY_MSGS[msg.subtype] || typeName;
                    else if (msg.type === 0x00 && CCC_CONSTANTS.FRAMEWORK_MSGS && CCC_CONSTANTS.FRAMEWORK_MSGS[msg.subtype]) typeName = CCC_CONSTANTS.FRAMEWORK_MSGS[msg.subtype];

                    const innerMessage = msg._decoded ? (msg._decoded.innerMsg || "-") : "-";
                    const params = msg._decoded ? (msg._decoded.params || "") : "";
                    const paramsText = params.replace(/<[^>]*>/g, '');

                    let handleNumber = -1;
                    if (msg.handle !== undefined && msg.handle !== null) {
                        if (typeof msg.handle === 'string' && msg.handle.startsWith('0x')) {
                            handleNumber = parseInt(msg.handle, 16);
                        } else {
                            handleNumber = Number(msg.handle);
                        }
                    }
                    const peerAddress = msg.peerAddress || btsnoopConnectionMap.get(handleNumber)?.address || 'N/A';

                    return {
                        Time: msg.timestamp,
                        'BLE Address': peerAddress,
                        Dir: msg.direction,
                        'Category': categoryName,
                        'Type': typeName,
                        'Message': innerMessage,
                        'Parameters': paramsText,
                        'Raw Data': msg.fullHex
                    };
                });

                const ws = XLSX.utils.json_to_sheet(exportData);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "CCC_Analysis");
                XLSX.writeFile(wb, "ccc_analysis.xlsx");
            });
        }
    }

    updateCccTableBody(container);

    makeSortable('cccStatsTable', 0, 'desc');

    // restoreTableScroll('cccTable'); // Is this function global? It was helper in components.
    // If restoreTableScroll is global in main.js, we can't use it easily here unless we pass it 
    // or better, extract table utils cleanly. 
    // For now, I will omit strict scroll restoration or assume it logic is simple.
}

function updateCccTableBody(container) {
    const tbody = container.querySelector('tbody');
    if (!tbody) return;

    currentRenderJobId++;
    const myJobId = currentRenderJobId;

    // Show loading state initially if data exists
    if (cccStatsData.length > 0) {
        tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 20px; color: #888;">Processing data...</td></tr>';
    } else {
        tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 20px; color: #888;">No data available.</td></tr>';
        return;
    }

    // Defer processing to prevent blocking
    setTimeout(() => {
        if (myJobId !== currentRenderJobId) return;

        const allData = cccStatsData;
        const total = allData.length;
        let i = 0;
        let isFirstChunk = true;
        let anyMatchesFound = false; // Track if any row matched filters across all chunks

        function processChunk() {
            if (myJobId !== currentRenderJobId) return;

            const startTime = performance.now();
            const chunkHtmlParts = [];
            let chunkHasMatches = false;

            // Process for up to 12ms (leaving ~4ms for browser overhead in a 60fps frame)
            while (i < total && (performance.now() - startTime < 12)) {
                const msg = allData[i];
                i++; // Increment index immediately

                // --- 1. Decode Payload (Lazy) ---
                if (!msg._decoded) {
                    try {
                        msg._decoded = decodePayload(msg.type, msg.subtype, msg.payload);
                    } catch (e) {
                        // Fallback for decoding errors
                        msg._decoded = { innerMsg: 'Error', params: 'Decoding error' };
                    }
                }

                // --- 2. Resolve Display Values ---
                const categoryName = (msg.type !== undefined && CCC_CONSTANTS.MESSAGE_TYPES[msg.type]) || (msg.type !== undefined ? `Unknown (0x${msg.type.toString(16).padStart(2, '0').toUpperCase()})` : 'Unknown Type');

                let typeName = `Unknown`;
                if (msg.type === 0x02) typeName = CCC_CONSTANTS.UWB_RANGING_MSGS[msg.subtype] || typeName;
                else if (msg.type === 0x03) typeName = CCC_CONSTANTS.DK_EVENT_CATEGORIES[msg.subtype] || typeName;
                else if (msg.type === 0x01 && CCC_CONSTANTS.SE_MSGS && CCC_CONSTANTS.SE_MSGS[msg.subtype]) typeName = CCC_CONSTANTS.SE_MSGS[msg.subtype];
                else if (msg.type === 0x05) typeName = CCC_CONSTANTS.SUPPLEMENTARY_MSGS[msg.subtype] || typeName;
                else if (msg.type === 0x00 && CCC_CONSTANTS.FRAMEWORK_MSGS && CCC_CONSTANTS.FRAMEWORK_MSGS[msg.subtype]) typeName = CCC_CONSTANTS.FRAMEWORK_MSGS[msg.subtype];

                const subtypeHex = (msg.subtype !== undefined) ? `0x${msg.subtype.toString(16).padStart(2, '0').toUpperCase()}` : 'N/A';
                let displayType = typeName;
                let displayTypeHtml = typeName;
                if (typeName === 'Unknown') {
                    displayType = subtypeHex;
                    displayTypeHtml = subtypeHex;
                } else {
                    displayType = `${typeName} (${subtypeHex})`;
                    displayTypeHtml = `${typeName} <span style="font-size: 0.85em; color: #888;">(${subtypeHex})</span>`;
                }

                const innerMessage = msg._decoded.innerMsg || "-";
                // Truncate params if huge to prevent DOM freeze
                const params = msg._decoded.params || "";
                let paramsText = "";
                if (params.length > 10000) {
                    paramsText = "[Large Data]";
                } else {
                    paramsText = params.replace(/<[^>]*>/g, '');
                }

                let handleNumber = -1;
                if (msg.handle !== undefined && msg.handle !== null) {
                    if (typeof msg.handle === 'string' && msg.handle.startsWith('0x')) {
                        handleNumber = parseInt(msg.handle, 16);
                    } else {
                        handleNumber = Number(msg.handle);
                    }
                }
                const peerAddress = msg.peerAddress || btsnoopConnectionMap.get(handleNumber)?.address || 'N/A';

                // --- 3. Filter Check ---
                if (cccColumnFilters.size > 0) {
                    const columns = [
                        msg.timestamp,
                        peerAddress,
                        msg.direction,
                        categoryName,
                        displayType,
                        innerMessage,
                        paramsText,
                        msg.fullHex
                    ];

                    const passesFilter = Array.from(cccColumnFilters.entries()).every(([colIndex, filterValue]) => {
                        const cellValue = String(columns[colIndex]).toLowerCase();
                        return cellValue.includes(filterValue);
                    });

                    if (!passesFilter) continue;
                }

                chunkHasMatches = true;
                anyMatchesFound = true; // At least one row has matched so far

                // --- 4. Generate Row HTML ---
                // Safety check for timestamp
                const safeTimestamp = msg.timestamp || "";
                const rowId = `ccc-${safeTimestamp.replace(/[^a-zA-Z0-9]/g, '')}-${msg.type}-${msg.subtype}`;

                chunkHtmlParts.push(`<tr data-row-id="${rowId}">
                    <td class="copy-cell" data-log-text="${safeTimestamp}">${safeTimestamp}</td>
                    <td class="copy-cell" data-log-text="${peerAddress}">${peerAddress}</td>
                    <td><span class="badge ${msg.direction === 'Sending' ? 'badge-out' : 'badge-in'}">${msg.direction}</span></td>
                    <td class="copy-cell" data-log-text="${categoryName}">${categoryName}</td>
                    <td class="copy-cell" data-log-text="${displayType.replace(/<[^>]*>/g, '')}">${displayTypeHtml}</td>
                    <td class="copy-cell" data-log-text="${innerMessage}">${innerMessage}</td>
                    <td class="copy-cell params-cell" data-log-text="${paramsText}" style="overflow-wrap: anywhere; word-break: break-all;">${params}</td>
                    <td class="copy-cell" data-log-text="${msg.fullHex}" style="color: #999;">${msg.fullHex}</td>
                </tr>`);
            }

            // --- 5. Append Chunk to DOM ---
            if (chunkHtmlParts.length > 0) {
                if (isFirstChunk) {
                    tbody.innerHTML = chunkHtmlParts.join('');
                    isFirstChunk = false;
                } else {
                    tbody.insertAdjacentHTML('beforeend', chunkHtmlParts.join(''));
                }
            } else if (isFirstChunk && i >= total) {
                // If this is the first chunk and we've processed all data, and no matches were found in this chunk
                // (meaning no matches were found at all), then display "No matching messages found."
                tbody.innerHTML = '<tr><td colspan="8">No matching messages found.</td></tr>';
                isFirstChunk = false; // Prevent logic issue in empty set
            }

            // --- 6. Schedule Next Chunk ---
            if (i < total) {
                // Use setTimeout with 0 which is sufficient to yield to UI thread
                setTimeout(processChunk, 0);
            } else if (!anyMatchesFound) {
                // If we've processed all data (i >= total) and no matches were found across any chunk
                tbody.innerHTML = '<tr><td colspan="8">No matching messages found.</td></tr>';
            }
        }

        processChunk();
    }, 0);
}
